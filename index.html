<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>NEON PONG: MULTIPLAYER EDITION</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    body {
        margin: 0;
        background-color: #050505;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        overflow: hidden;
        font-family: 'Press Start 2P', cursive;
    }

    #game-container {
        position: relative;
        box-shadow: 0 0 50px rgba(0, 255, 255, 0.2);
        border: 4px solid #333;
        border-radius: 4px;
    }

    canvas {
        display: block;
        background: radial-gradient(circle at center, #1a1a1a, #000000);
    }

    .scanlines {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
            to bottom,
            rgba(255,255,255,0),
            rgba(255,255,255,0) 50%,
            rgba(0,0,0,0.2) 50%,
            rgba(0,0,0,0.2)
        );
        background-size: 100% 4px;
        pointer-events: none;
        z-index: 10;
        box-shadow: inset 0 0 100px rgba(0,0,0,0.9);
    }

    #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 20;
        text-align: center;
        color: white;
        text-shadow: 4px 4px #ff00de;
    }

    .hidden { display: none !important; }
    
    h1 { 
        font-size: 40px; 
        margin-bottom: 30px; 
        color: #0ff; 
    }
    
    p { 
        font-size: 14px; 
        color: #aaa; 
        line-height: 1.5; 
    }
    
    .menu-section {
        margin: 15px 0;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    
    label {
        font-size: 12px;
        color: #0ff;
        margin-bottom: 8px;
        text-shadow: 2px 2px #ff00de;
    }
    
    input, select {
        font-family: 'Press Start 2P', cursive;
        font-size: 12px;
        padding: 10px 20px;
        background-color: #1a1a1a;
        color: #0ff;
        border: 2px solid #0ff;
        border-radius: 4px;
        text-shadow: 0 0 5px #0ff;
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        text-align: center;
        width: 250px;
    }
    
    input {
        cursor: text;
    }
    
    select {
        cursor: pointer;
    }
    
    input:focus, select:hover {
        background-color: #2a2a2a;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        outline: none;
    }
    
    select option {
        background-color: #1a1a1a;
        color: #0ff;
    }
    
    button {
        font-family: 'Press Start 2P', cursive;
        font-size: 14px;
        padding: 15px 30px;
        margin: 10px;
        background-color: #1a1a1a;
        color: #ff0;
        border: 3px solid #ff0;
        border-radius: 4px;
        cursor: pointer;
        text-shadow: 0 0 10px #ff0;
        box-shadow: 0 0 20px rgba(255, 255, 0, 0.4);
        transition: all 0.3s;
    }
    
    button:hover:not(:disabled) {
        background-color: #ff0;
        color: #000;
        transform: scale(1.05);
        box-shadow: 0 0 30px rgba(255, 255, 0, 0.8);
    }
    
    button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .status {
        font-size: 10px;
        color: #ff0;
        margin-top: 15px;
        min-height: 20px;
    }
    
    .room-code {
        font-size: 24px;
        color: #0f0;
        margin: 20px 0;
        padding: 15px 30px;
        background-color: rgba(0, 255, 0, 0.1);
        border: 2px solid #0f0;
        border-radius: 8px;
        text-shadow: 0 0 10px #0f0;
        letter-spacing: 5px;
    }
    
    .blink { 
        animation: blinker 1s linear infinite; 
    }

    @keyframes blinker { 
        50% { opacity: 0; } 
    }

    .button-group {
        display: flex;
        gap: 10px;
        margin-top: 20px;
    }
</style>
</head>
<body>

<div id="game-container">
    <canvas id="game" width="900" height="500"></canvas>
    <div class="scanlines"></div>
    
    <div id="ui-layer">
        <h1>NEON PONG</h1>
        <div id="menu-screen">
            <p style="margin-bottom: 20px;">Multiplayer Edition â€¢ First to 10 Wins</p>
            
            <div class="menu-section">
                <label>YOUR PADDLE COLOR:</label>
                <select id="paddle-color">
                    <option value="#0ff" selected>CYAN</option>
                    <option value="#0f0">GREEN</option>
                    <option value="#ff0">YELLOW</option>
                    <option value="#f0f">MAGENTA</option>
                    <option value="#00f">BLUE</option>
                    <option value="#f80">ORANGE</option>
                    <option value="#fff">WHITE</option>
                </select>
            </div>
            
            <div class="menu-section">
                <label>BALL COLOR:</label>
                <select id="ball-color">
                    <option value="#fff" selected>WHITE</option>
                    <option value="#0ff">CYAN</option>
                    <option value="#0f0">GREEN</option>
                    <option value="#ff0">YELLOW</option>
                    <option value="#f0f">MAGENTA</option>
                    <option value="#f00">RED</option>
                    <option value="#f80">ORANGE</option>
                </select>
            </div>
            
            <div class="button-group">
                <button id="create-btn">CREATE ROOM</button>
                <button id="show-join-btn">JOIN ROOM</button>
            </div>
            
            <div id="join-section" class="hidden">
                <div class="menu-section">
                    <label>ENTER ROOM CODE:</label>
                    <input type="text" id="room-code-input" placeholder="Enter 6-digit code" maxlength="6">
                </div>
                <button id="join-btn">CONNECT</button>
            </div>
            
            <div id="waiting-section" class="hidden">
                <p>Your Room Code:</p>
                <div class="room-code" id="room-code-display"></div>
                <p class="blink">Waiting for opponent to join...</p>
            </div>
            
            <div class="status" id="status"></div>
        </div>
        
        <div id="gameover-screen" class="hidden"></div>
    </div>
</div>

<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script>
/**
 * MULTIPLAYER NEON PONG
 * Uses PeerJS for peer-to-peer connection
 */

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const uiLayer = document.getElementById("ui-layer");
const menuScreen = document.getElementById("menu-screen");
const gameoverScreen = document.getElementById("gameover-screen");
const createBtn = document.getElementById("create-btn");
const showJoinBtn = document.getElementById("show-join-btn");
const joinBtn = document.getElementById("join-btn");
const joinSection = document.getElementById("join-section");
const waitingSection = document.getElementById("waiting-section");
const roomCodeDisplay = document.getElementById("room-code-display");
const roomCodeInput = document.getElementById("room-code-input");
const statusEl = document.getElementById("status");

const PADDLE_H = 80;
const PADDLE_W = 15;
const WIN_SCORE = 10;

// Colors
let COLOR_PLAYER = "#0ff";
let COLOR_OPPONENT = "#ff00de";
let COLOR_BALL = "#fff";

// Multiplayer state
let peer = null;
let connection = null;
let roomCode = "";
let playerSide = null;
let gameState = "MENU";
let shakeIntensity = 0;
let isHost = false;

/**
 * AUDIO ENGINE
 */
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx;

function initAudio() {
    if (!audioCtx) audioCtx = new AudioContext();
    if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playSound(type) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    const now = audioCtx.currentTime;

    if (type === "hit") {
        osc.type = "square";
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
    } else if (type === "wall") {
        osc.type = "sine";
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.linearRampToValueAtTime(100, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
    } else if (type === "score") {
        osc.type = "triangle";
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.linearRampToValueAtTime(600, now + 0.2);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0.01, now + 0.4);
        osc.start(now);
        osc.stop(now + 0.4);
    }
}

/**
 * PARTICLES
 */
let particles = [];
class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.size = Math.random() * 5 + 2;
        this.speedX = Math.random() * 6 - 3;
        this.speedY = Math.random() * 6 - 3;
        this.color = color;
        this.life = 1.0;
    }
    update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.life -= 0.03;
        this.size *= 0.95;
    }
    draw() {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1.0;
    }
}

let trail = [];

let leftPaddle = { x: 20, y: 200, score: 0, color: COLOR_PLAYER };
let rightPaddle = { x: canvas.width - 35, y: 200, score: 0, color: COLOR_OPPONENT };
let ball = { x: 450, y: 250, dx: 5, dy: 3, r: 8, speed: 7 };

const keys = {};
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup", e => keys[e.key] = false);

/**
 * MULTIPLAYER FUNCTIONS
 */

function generateRoomCode() {
    return Math.floor(100000 + Math.random() * 900000).toString();
}

function createRoom() {
    initAudio();
    COLOR_PLAYER = document.getElementById("paddle-color").value;
    COLOR_BALL = document.getElementById("ball-color").value;
    
    roomCode = generateRoomCode();
    playerSide = "left";
    isHost = true;
    
    // Initialize PeerJS
    peer = new Peer(roomCode);
    
    peer.on('open', (id) => {
        roomCodeDisplay.textContent = roomCode;
        waitingSection.classList.remove("hidden");
        createBtn.disabled = true;
        showJoinBtn.disabled = true;
        statusEl.textContent = "Room created! Share the code with your friend.";
    });
    
    peer.on('connection', (conn) => {
        connection = conn;
        
        connection.on('open', () => {
            // Send initial game setup to joining player
            connection.send({
                type: 'setup',
                ballColor: COLOR_BALL,
                hostColor: COLOR_PLAYER
            });
            
            statusEl.textContent = "Opponent connected! Starting game...";
            setTimeout(startGame, 2000);
        });
        
        connection.on('data', (data) => {
            if (data.type === 'paddle') {
                rightPaddle.y = data.y;
            }
        });
    });
    
    peer.on('error', (err) => {
        console.error('PeerJS error:', err);
        statusEl.textContent = "Connection error. Please try again.";
    });
}

function joinRoom() {
    const code = roomCodeInput.value.trim();
    if (!code || code.length !== 6) {
        statusEl.textContent = "Please enter a valid 6-digit room code";
        return;
    }
    
    initAudio();
    COLOR_PLAYER = document.getElementById("paddle-color").value;
    
    playerSide = "right";
    isHost = false;
    
    // Initialize PeerJS with random ID
    peer = new Peer();
    
    peer.on('open', () => {
        statusEl.textContent = "Connecting to room...";
        connection = peer.connect(code);
        
        connection.on('open', () => {
            statusEl.textContent = "Connected! Waiting for game to start...";
            
            connection.on('data', (data) => {
                if (data.type === 'setup') {
                    COLOR_BALL = data.ballColor;
                    COLOR_OPPONENT = data.hostColor;
                    setTimeout(startGame, 2000);
                } else if (data.type === 'paddle') {
                    leftPaddle.y = data.y;
                } else if (data.type === 'ball') {
                    ball.x = data.x;
                    ball.y = data.y;
                    ball.dx = data.dx;
                    ball.dy = data.dy;
                    ball.speed = data.speed;
                } else if (data.type === 'score') {
                    leftPaddle.score = data.leftScore;
                    rightPaddle.score = data.rightScore;
                }
            });
        });
        
        connection.on('error', (err) => {
            console.error('Connection error:', err);
            statusEl.textContent = "Failed to connect. Check the room code.";
        });
    });
}

function startGame() {
    gameState = "PLAYING";
    menuScreen.classList.add("hidden");
    resetBall();
    
    // Set up continuous paddle sync
    setInterval(() => {
        if (connection && connection.open && gameState === "PLAYING") {
            const myPaddle = playerSide === "left" ? leftPaddle : rightPaddle;
            connection.send({
                type: 'paddle',
                y: myPaddle.y
            });
        }
    }, 16); // ~60fps
}

/**
 * GAME LOGIC
 */

function spawnParticles(x, y, color) {
    for (let i = 0; i < 15; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function resetBall() {
    ball.x = canvas.width / 2;
    ball.y = canvas.height / 2;
    ball.speed = 7;
    ball.dx = (Math.random() > 0.5 ? 1 : -1) * ball.speed;
    ball.dy = (Math.random() * 6) - 3;
    trail = [];
}

function update() {
    if (gameState !== "PLAYING") return;

    // Control your paddle
    const myPaddle = playerSide === "left" ? leftPaddle : rightPaddle;
    
    if (keys["w"] && myPaddle.y > 0) myPaddle.y -= 8;
    if (keys["s"] && myPaddle.y < canvas.height - PADDLE_H) myPaddle.y += 8;
    
    // Only the host runs ball physics
    if (isHost) {
        ball.x += ball.dx;
        ball.y += ball.dy;

        trail.push({x: ball.x, y: ball.y});
        if(trail.length > 20) trail.shift();

        // Wall Collisions
        if (ball.y - ball.r <= 0 || ball.y + ball.r >= canvas.height) {
            ball.dy *= -1;
            playSound("wall");
            shakeIntensity = 5;
        }

        // Paddle Collisions
        function checkCollision(paddle) {
            return ball.x - ball.r < paddle.x + PADDLE_W &&
                   ball.x + ball.r > paddle.x &&
                   ball.y > paddle.y &&
                   ball.y < paddle.y + PADDLE_H;
        }

        // Left Paddle Hit
        if (checkCollision(leftPaddle)) {
            let collidePoint = (ball.y - (leftPaddle.y + PADDLE_H / 2));
            collidePoint = collidePoint / (PADDLE_H / 2);
            
            ball.speed = Math.min(ball.speed * 1.05, 18); 
            
            let angleRad = (Math.PI / 4) * collidePoint;
            
            ball.dx = ball.speed * Math.cos(angleRad);
            ball.dy = ball.speed * Math.sin(angleRad);
            
            ball.x = leftPaddle.x + PADDLE_W + ball.r + 1;

            playSound("hit");
            spawnParticles(ball.x, ball.y, leftPaddle.color);
            shakeIntensity = 10;
        }

        // Right Paddle Hit
        if (checkCollision(rightPaddle)) {
            let collidePoint = (ball.y - (rightPaddle.y + PADDLE_H / 2));
            collidePoint = collidePoint / (PADDLE_H / 2);
            
            ball.speed = Math.min(ball.speed * 1.05, 18);

            let angleRad = (Math.PI / 4) * collidePoint;
            
            ball.dx = -ball.speed * Math.cos(angleRad);
            ball.dy = ball.speed * Math.sin(angleRad);

            ball.x = rightPaddle.x - ball.r - 1;

            playSound("hit");
            spawnParticles(ball.x, ball.y, rightPaddle.color);
            shakeIntensity = 10;
        }

        // Scoring
        if (ball.x < 0) {
            rightPaddle.score++;
            playSound("score");
            resetBall();
            
            if (connection && connection.open) {
                connection.send({
                    type: 'score',
                    leftScore: leftPaddle.score,
                    rightScore: rightPaddle.score
                });
            }
            checkWin();
        }
        if (ball.x > canvas.width) {
            leftPaddle.score++;
            playSound("score");
            resetBall();
            
            if (connection && connection.open) {
                connection.send({
                    type: 'score',
                    leftScore: leftPaddle.score,
                    rightScore: rightPaddle.score
                });
            }
            checkWin();
        }
        
        // Send ball state to opponent
        if (connection && connection.open) {
            connection.send({
                type: 'ball',
                x: ball.x,
                y: ball.y,
                dx: ball.dx,
                dy: ball.dy,
                speed: ball.speed
            });
        }
    } else {
        // Client updates trail
        trail.push({x: ball.x, y: ball.y});
        if(trail.length > 20) trail.shift();
    }

    // Particles & Shake
    particles.forEach((p, index) => {
        p.update();
        if (p.life <= 0) particles.splice(index, 1);
    });

    if (shakeIntensity > 0) shakeIntensity *= 0.9;
    if (shakeIntensity < 0.5) shakeIntensity = 0;
}

function checkWin() {
    if (leftPaddle.score >= WIN_SCORE || rightPaddle.score >= WIN_SCORE) {
        gameState = "GAMEOVER";
        
        const youWon = (playerSide === "left" && leftPaddle.score >= WIN_SCORE) || 
                       (playerSide === "right" && rightPaddle.score >= WIN_SCORE);
        
        const winnerText = youWon ? "YOU WIN!" : "YOU LOSE";
        
        gameoverScreen.innerHTML = `
            <h1 style="color:${youWon ? '#0f0' : '#f00'}; text-shadow: 4px 4px ${youWon ? '#0a0' : '#a00'}">${winnerText}</h1>
            <p style="font-size: 16px; margin: 20px 0;">Final Score: ${leftPaddle.score} - ${rightPaddle.score}</p>
            <button id="menu-btn">BACK TO MENU</button>
        `;
        
        gameoverScreen.classList.remove("hidden");
        
        document.getElementById("menu-btn").addEventListener("click", () => {
            location.reload();
        });
    }
}

/**
 * RENDERING
 */

function drawNet() {
    ctx.beginPath();
    ctx.setLineDash([10, 15]);
    ctx.lineWidth = 4;
    ctx.strokeStyle = "#333";
    ctx.moveTo(canvas.width / 2, 0);
    ctx.lineTo(canvas.width / 2, canvas.height);
    ctx.stroke();
    ctx.setLineDash([]);
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    if (shakeIntensity > 0) {
        let dx = (Math.random() - 0.5) * shakeIntensity;
        let dy = (Math.random() - 0.5) * shakeIntensity;
        ctx.translate(dx, dy);
    }

    drawNet();

    // Draw Trail
    for (let i = 0; i < trail.length; i++) {
        let pos = trail[i];
        let ratio = (i + 1) / trail.length;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, ball.r * ratio, 0, Math.PI * 2);
        let r = parseInt(COLOR_BALL.slice(1,3), 16);
        let g = parseInt(COLOR_BALL.slice(3,5), 16);
        let b = parseInt(COLOR_BALL.slice(5,7), 16);
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${ratio * 0.5})`;
        ctx.fill();
    }

    particles.forEach(p => p.draw());

    // Set colors
    if (playerSide === "left") {
        leftPaddle.color = COLOR_PLAYER;
        rightPaddle.color = COLOR_OPPONENT;
    } else {
        leftPaddle.color = COLOR_OPPONENT;
        rightPaddle.color = COLOR_PLAYER;
    }

    // Draw Left Paddle
    ctx.shadowBlur = 20;
    ctx.shadowColor = leftPaddle.color;
    ctx.fillStyle = leftPaddle.color;
    ctx.fillRect(leftPaddle.x, leftPaddle.y, PADDLE_W, PADDLE_H);

    // Draw Right Paddle
    ctx.shadowColor = rightPaddle.color;
    ctx.fillStyle = rightPaddle.color;
    ctx.fillRect(rightPaddle.x, rightPaddle.y, PADDLE_W, PADDLE_H);

    // Draw Ball
    ctx.shadowBlur = 15;
    ctx.shadowColor = COLOR_BALL;
    ctx.fillStyle = COLOR_BALL;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.restore();

    // Draw Score
    ctx.font = "60px 'Press Start 2P'";
    ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
    ctx.textAlign = "center";
    ctx.fillText(leftPaddle.score, canvas.width / 4, canvas.height / 2 + 20);
    ctx.fillText(rightPaddle.score, canvas.width * 0.75, canvas.height / 2 + 20);
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

// Event Listeners
createBtn.addEventListener("click", createRoom);

showJoinBtn.addEventListener("click", () => {
    joinSection.classList.remove("hidden");
    createBtn.disabled = true;
    showJoinBtn.disabled = true;
});

joinBtn.addEventListener("click", joinRoom);

roomCodeInput.addEventListener("keypress", (e) => {
    if (e.key === "Enter") joinRoom();
});

// Touch controls
canvas.addEventListener("touchmove", e => {
    e.preventDefault();
    const myPaddle = playerSide === "left" ? leftPaddle : rightPaddle;
    let rect = canvas.getBoundingClientRect();
    let y = e.touches[0].clientY - rect.top;
    myPaddle.y = y - PADDLE_H / 2;
}, { passive: false });

loop();

</script>

</body>
</html>
