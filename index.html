<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>NEON PONG: MULTIPLAYER EDITION</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    body {
        margin: 0;
        background-color: #050505;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        overflow: hidden;
        font-family: 'Press Start 2P', cursive;
    }

    #game-container {
        position: relative;
        box-shadow: 0 0 50px rgba(0, 255, 255, 0.2);
        border: 4px solid #333;
        border-radius: 4px;
    }

    canvas {
        display: block;
        background: radial-gradient(circle at center, #1a1a1a, #000000);
    }

    .scanlines {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
            to bottom,
            rgba(255,255,255,0),
            rgba(255,255,255,0) 50%,
            rgba(0,0,0,0.2) 50%,
            rgba(0,0,0,0.2)
        );
        background-size: 100% 4px;
        pointer-events: none;
        z-index: 10;
        box-shadow: inset 0 0 100px rgba(0,0,0,0.9);
    }

    #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 20;
        text-align: center;
        color: white;
        text-shadow: 4px 4px #ff00de;
    }

    .hidden { display: none !important; }
    
    h1 { 
        font-size: 40px; 
        margin-bottom: 30px; 
        color: #0ff; 
    }
    
    p { 
        font-size: 14px; 
        color: #aaa; 
        line-height: 1.5; 
    }
    
    .menu-section {
        margin: 15px 0;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    
    label {
        font-size: 12px;
        color: #0ff;
        margin-bottom: 8px;
        text-shadow: 2px 2px #ff00de;
    }
    
    input, select {
        font-family: 'Press Start 2P', cursive;
        font-size: 12px;
        padding: 10px 20px;
        background-color: #1a1a1a;
        color: #0ff;
        border: 2px solid #0ff;
        border-radius: 4px;
        text-shadow: 0 0 5px #0ff;
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        text-align: center;
    }
    
    input {
        cursor: text;
    }
    
    select {
        cursor: pointer;
    }
    
    input:focus, select:hover {
        background-color: #2a2a2a;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        outline: none;
    }
    
    select option {
        background-color: #1a1a1a;
        color: #0ff;
    }
    
    button {
        font-family: 'Press Start 2P', cursive;
        font-size: 14px;
        padding: 15px 30px;
        margin-top: 20px;
        background-color: #1a1a1a;
        color: #ff0;
        border: 3px solid #ff0;
        border-radius: 4px;
        cursor: pointer;
        text-shadow: 0 0 10px #ff0;
        box-shadow: 0 0 20px rgba(255, 255, 0, 0.4);
        transition: all 0.3s;
    }
    
    button:hover {
        background-color: #ff0;
        color: #000;
        transform: scale(1.05);
        box-shadow: 0 0 30px rgba(255, 255, 0, 0.8);
    }
    
    button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
    }
    
    .status {
        font-size: 10px;
        color: #ff0;
        margin-top: 15px;
        min-height: 20px;
    }
    
    .blink { 
        animation: blinker 1s linear infinite; 
    }

    @keyframes blinker { 
        50% { opacity: 0; } 
    }
</style>
</head>
<body>

<div id="game-container">
    <canvas id="game" width="900" height="500"></canvas>
    <div class="scanlines"></div>
    
    <div id="ui-layer">
        <h1>NEON PONG</h1>
        <div id="menu-screen">
            <p style="margin-bottom: 20px;">Multiplayer Edition</p>
            
            <div class="menu-section">
                <label>ROOM KEY:</label>
                <input type="text" id="room-key" placeholder="Enter 4-digit code" maxlength="10">
            </div>
            
            <div class="menu-section">
                <label>YOUR PADDLE:</label>
                <select id="paddle-color">
                    <option value="#0ff" selected>CYAN</option>
                    <option value="#0f0">GREEN</option>
                    <option value="#ff0">YELLOW</option>
                    <option value="#f0f">MAGENTA</option>
                    <option value="#00f">BLUE</option>
                    <option value="#f80">ORANGE</option>
                    <option value="#fff">WHITE</option>
                </select>
            </div>
            
            <div class="menu-section">
                <label>BALL COLOR:</label>
                <select id="ball-color">
                    <option value="#fff" selected>WHITE</option>
                    <option value="#0ff">CYAN</option>
                    <option value="#0f0">GREEN</option>
                    <option value="#ff0">YELLOW</option>
                    <option value="#f0f">MAGENTA</option>
                    <option value="#f00">RED</option>
                    <option value="#f80">ORANGE</option>
                </select>
            </div>
            
            <button id="join-btn">JOIN ROOM</button>
            <div class="status" id="status">Enter a room key to play with a friend</div>
        </div>
        
        <div id="gameover-screen" class="hidden"></div>
    </div>
</div>

<script>
/**
 * MULTIPLAYER NEON PONG
 * Uses persistent storage to sync game state between two players
 */

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const uiLayer = document.getElementById("ui-layer");
const menuScreen = document.getElementById("menu-screen");
const gameoverScreen = document.getElementById("gameover-screen");
const joinBtn = document.getElementById("join-btn");
const statusEl = document.getElementById("status");

const PADDLE_H = 80;
const PADDLE_W = 15;
const WIN_SCORE = 10;
const SYNC_INTERVAL = 50; // Sync every 50ms

// Colors
let COLOR_PLAYER = "#0ff";
let COLOR_OPPONENT = "#ff00de";
let COLOR_BALL = "#fff";

// Multiplayer state
let roomKey = "";
let playerId = "";
let playerSide = null; // "left" or "right"
let gameState = "MENU";
let shakeIntensity = 0;
let lastSync = 0;

/**
 * AUDIO ENGINE
 */
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx;

function initAudio() {
    if (!audioCtx) audioCtx = new AudioContext();
    if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playSound(type) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    const now = audioCtx.currentTime;

    if (type === "hit") {
        osc.type = "square";
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
    } else if (type === "wall") {
        osc.type = "sine";
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.linearRampToValueAtTime(100, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
    } else if (type === "score") {
        osc.type = "triangle";
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.linearRampToValueAtTime(600, now + 0.2);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0.01, now + 0.4);
        osc.start(now);
        osc.stop(now + 0.4);
    }
}

/**
 * PARTICLES
 */
let particles = [];
class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.size = Math.random() * 5 + 2;
        this.speedX = Math.random() * 6 - 3;
        this.speedY = Math.random() * 6 - 3;
        this.color = color;
        this.life = 1.0;
    }
    update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.life -= 0.03;
        this.size *= 0.95;
    }
    draw() {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1.0;
    }
}

let trail = [];

let leftPaddle = { x: 20, y: 200, score: 0, color: COLOR_PLAYER };
let rightPaddle = { x: canvas.width - 35, y: 200, score: 0, color: COLOR_OPPONENT };
let ball = { x: 450, y: 250, dx: 5, dy: 3, r: 8, speed: 7 };

const keys = {};
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup", e => keys[e.key] = false);

/**
 * MULTIPLAYER FUNCTIONS
 */

function generatePlayerId() {
    return 'player_' + Math.random().toString(36).substr(2, 9);
}

async function joinRoom() {
    const roomInput = document.getElementById("room-key").value.trim();
    if (!roomInput) {
        statusEl.textContent = "Please enter a room key";
        return;
    }
    
    roomKey = roomInput;
    playerId = generatePlayerId();
    
    initAudio();
    statusEl.textContent = "Joining room...";
    joinBtn.disabled = true;
    
    try {
        // Check if room exists
        const roomData = await window.storage.get(`room:${roomKey}`, true);
        
        if (!roomData) {
            // Create new room - you're player 1 (left side)
            playerSide = "left";
            COLOR_PLAYER = document.getElementById("paddle-color").value;
            COLOR_BALL = document.getElementById("ball-color").value;
            
            await window.storage.set(`room:${roomKey}`, JSON.stringify({
                player1: playerId,
                player2: null,
                player1Color: COLOR_PLAYER,
                ballColor: COLOR_BALL,
                created: Date.now()
            }), true);
            
            statusEl.textContent = "Waiting for opponent...";
            waitForOpponent();
        } else {
            // Join existing room - you're player 2 (right side)
            const room = JSON.parse(roomData.value);
            
            if (room.player2) {
                statusEl.textContent = "Room is full!";
                joinBtn.disabled = false;
                return;
            }
            
            playerSide = "right";
            COLOR_PLAYER = document.getElementById("paddle-color").value;
            COLOR_OPPONENT = room.player1Color;
            COLOR_BALL = room.ballColor;
            
            room.player2 = playerId;
            room.player2Color = COLOR_PLAYER;
            
            await window.storage.set(`room:${roomKey}`, JSON.stringify(room), true);
            
            // Initialize game state
            await initGameState();
            startGame();
        }
    } catch (error) {
        console.error("Error joining room:", error);
        statusEl.textContent = "Error joining room. Try again.";
        joinBtn.disabled = false;
    }
}

async function waitForOpponent() {
    const checkInterval = setInterval(async () => {
        try {
            const roomData = await window.storage.get(`room:${roomKey}`, true);
            if (roomData) {
                const room = JSON.parse(roomData.value);
                if (room.player2) {
                    clearInterval(checkInterval);
                    COLOR_OPPONENT = room.player2Color;
                    await initGameState();
                    startGame();
                }
            }
        } catch (error) {
            console.error("Error checking for opponent:", error);
        }
    }, 500);
}

async function initGameState() {
    const gameData = {
        ball: { x: 450, y: 250, dx: 5, dy: 3, speed: 7 },
        leftPaddle: { y: 200, score: 0 },
        rightPaddle: { y: 200, score: 0 },
        gameActive: true,
        lastUpdate: Date.now()
    };
    
    await window.storage.set(`game:${roomKey}`, JSON.stringify(gameData), true);
}

function startGame() {
    gameState = "PLAYING";
    menuScreen.classList.add("hidden");
    syncGame();
}

async function syncGame() {
    if (gameState !== "PLAYING") return;
    
    const now = Date.now();
    if (now - lastSync < SYNC_INTERVAL) return;
    lastSync = now;
    
    try {
        // Get current game state
        const gameData = await window.storage.get(`game:${roomKey}`, true);
        if (!gameData) return;
        
        const state = JSON.parse(gameData.value);
        
        // Update my paddle position
        if (playerSide === "left") {
            state.leftPaddle.y = leftPaddle.y;
        } else {
            state.rightPaddle.y = rightPaddle.y;
        }
        
        // Only the left player (host) updates ball physics
        if (playerSide === "left") {
            state.ball = {
                x: ball.x,
                y: ball.y,
                dx: ball.dx,
                dy: ball.dy,
                speed: ball.speed
            };
            state.leftPaddle.score = leftPaddle.score;
            state.rightPaddle.score = rightPaddle.score;
        } else {
            // Right player reads ball state from host
            ball.x = state.ball.x;
            ball.y = state.ball.y;
            ball.dx = state.ball.dx;
            ball.dy = state.ball.dy;
            ball.speed = state.ball.speed;
            leftPaddle.score = state.leftPaddle.score;
            rightPaddle.score = state.rightPaddle.score;
        }
        
        // Both players read opponent paddle position
        if (playerSide === "left") {
            rightPaddle.y = state.rightPaddle.y;
        } else {
            leftPaddle.y = state.leftPaddle.y;
        }
        
        state.lastUpdate = now;
        await window.storage.set(`game:${roomKey}`, JSON.stringify(state), true);
        
    } catch (error) {
        console.error("Sync error:", error);
    }
}

/**
 * GAME LOGIC
 */

function spawnParticles(x, y, color) {
    for (let i = 0; i < 15; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function resetBall() {
    ball.x = canvas.width / 2;
    ball.y = canvas.height / 2;
    ball.speed = 7;
    ball.dx = (Math.random() > 0.5 ? 1 : -1) * ball.speed;
    ball.dy = (Math.random() * 6) - 3;
    trail = [];
}

function update() {
    if (gameState !== "PLAYING") return;
    
    // Sync with server
    syncGame();

    // Control your paddle
    const myPaddle = playerSide === "left" ? leftPaddle : rightPaddle;
    
    if (keys["w"] && myPaddle.y > 0) myPaddle.y -= 8;
    if (keys["s"] && myPaddle.y < canvas.height - PADDLE_H) myPaddle.y += 8;
    
    // Only the host (left player) runs ball physics
    if (playerSide === "left") {
        // Ball Physics
        ball.x += ball.dx;
        ball.y += ball.dy;

        // Trail logic
        trail.push({x: ball.x, y: ball.y});
        if(trail.length > 20) trail.shift();

        // Wall Collisions
        if (ball.y - ball.r <= 0 || ball.y + ball.r >= canvas.height) {
            ball.dy *= -1;
            playSound("wall");
            shakeIntensity = 5;
        }

        // Paddle Collisions
        function checkCollision(paddle) {
            return ball.x - ball.r < paddle.x + PADDLE_W &&
                   ball.x + ball.r > paddle.x &&
                   ball.y > paddle.y &&
                   ball.y < paddle.y + PADDLE_H;
        }

        // Left Paddle Hit
        if (checkCollision(leftPaddle)) {
            let collidePoint = (ball.y - (leftPaddle.y + PADDLE_H / 2));
            collidePoint = collidePoint / (PADDLE_H / 2);
            
            ball.speed = Math.min(ball.speed * 1.05, 18); 
            
            let angleRad = (Math.PI / 4) * collidePoint;
            
            ball.dx = ball.speed * Math.cos(angleRad);
            ball.dy = ball.speed * Math.sin(angleRad);
            
            ball.x = leftPaddle.x + PADDLE_W + ball.r + 1;

            playSound("hit");
            spawnParticles(ball.x, ball.y, leftPaddle.color);
            shakeIntensity = 10;
        }

        // Right Paddle Hit
        if (checkCollision(rightPaddle)) {
            let collidePoint = (ball.y - (rightPaddle.y + PADDLE_H / 2));
            collidePoint = collidePoint / (PADDLE_H / 2);
            
            ball.speed = Math.min(ball.speed * 1.05, 18);

            let angleRad = (Math.PI / 4) * collidePoint;
            
            ball.dx = -ball.speed * Math.cos(angleRad);
            ball.dy = ball.speed * Math.sin(angleRad);

            ball.x = rightPaddle.x - ball.r - 1;

            playSound("hit");
            spawnParticles(ball.x, ball.y, rightPaddle.color);
            shakeIntensity = 10;
        }

        // Scoring
        if (ball.x < 0) {
            rightPaddle.score++;
            checkWin();
            playSound("score");
            resetBall();
        }
        if (ball.x > canvas.width) {
            leftPaddle.score++;
            checkWin();
            playSound("score");
            resetBall();
        }
    } else {
        // Right player: update trail based on received ball position
        trail.push({x: ball.x, y: ball.y});
        if(trail.length > 20) trail.shift();
    }

    // Particles & Shake Update (both players)
    particles.forEach((p, index) => {
        p.update();
        if (p.life <= 0) particles.splice(index, 1);
    });

    if (shakeIntensity > 0) shakeIntensity *= 0.9;
    if (shakeIntensity < 0.5) shakeIntensity = 0;
}

function checkWin() {
    if (leftPaddle.score >= WIN_SCORE || rightPaddle.score >= WIN_SCORE) {
        gameState = "GAMEOVER";
        
        const youWon = (playerSide === "left" && leftPaddle.score >= WIN_SCORE) || 
                       (playerSide === "right" && rightPaddle.score >= WIN_SCORE);
        
        const winnerText = youWon ? "YOU WIN" : "YOU LOSE";
        
        gameoverScreen.innerHTML = `
            <h1 style="color:${youWon ? '#0f0' : '#f00'}; text-shadow: 4px 4px ${youWon ? '#0a0' : '#a00'}">${winnerText}</h1>
            <p style="font-size: 16px; margin: 20px 0;">Score: ${leftPaddle.score} - ${rightPaddle.score}</p>
            <button id="menu-btn">BACK TO MENU</button>
        `;
        
        gameoverScreen.classList.remove("hidden");
        
        document.getElementById("menu-btn").addEventListener("click", () => {
            location.reload();
        });
    }
}

/**
 * RENDERING
 */

function drawNet() {
    ctx.beginPath();
    ctx.setLineDash([10, 15]);
    ctx.lineWidth = 4;
    ctx.strokeStyle = "#333";
    ctx.moveTo(canvas.width / 2, 0);
    ctx.lineTo(canvas.width / 2, canvas.height);
    ctx.stroke();
    ctx.setLineDash([]);
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    if (shakeIntensity > 0) {
        let dx = (Math.random() - 0.5) * shakeIntensity;
        let dy = (Math.random() - 0.5) * shakeIntensity;
        ctx.translate(dx, dy);
    }

    drawNet();

    // Draw Trail
    for (let i = 0; i < trail.length; i++) {
        let pos = trail[i];
        let ratio = (i + 1) / trail.length;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, ball.r * ratio, 0, Math.PI * 2);
        let r = parseInt(COLOR_BALL.slice(1,3), 16);
        let g = parseInt(COLOR_BALL.slice(3,5), 16);
        let b = parseInt(COLOR_BALL.slice(5,7), 16);
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${ratio * 0.5})`;
        ctx.fill();
    }

    particles.forEach(p => p.draw());

    // Set colors based on player side
    if (playerSide === "left") {
        leftPaddle.color = COLOR_PLAYER;
        rightPaddle.color = COLOR_OPPONENT;
    } else {
        leftPaddle.color = COLOR_OPPONENT;
        rightPaddle.color = COLOR_PLAYER;
    }

    // Draw Left Paddle
    ctx.shadowBlur = 20;
    ctx.shadowColor = leftPaddle.color;
    ctx.fillStyle = leftPaddle.color;
    ctx.fillRect(leftPaddle.x, leftPaddle.y, PADDLE_W, PADDLE_H);

    // Draw Right Paddle
    ctx.shadowColor = rightPaddle.color;
    ctx.fillStyle = rightPaddle.color;
    ctx.fillRect(rightPaddle.x, rightPaddle.y, PADDLE_W, PADDLE_H);

    // Draw Ball
    ctx.shadowBlur = 15;
    ctx.shadowColor = COLOR_BALL;
    ctx.fillStyle = COLOR_BALL;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.restore();

    // Draw Score
    ctx.font = "60px 'Press Start 2P'";
    ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
    ctx.textAlign = "center";
    ctx.fillText(leftPaddle.score, canvas.width / 4, canvas.height / 2 + 20);
    ctx.fillText(rightPaddle.score, canvas.width * 0.75, canvas.height / 2 + 20);
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

// Event Listeners
joinBtn.addEventListener("click", joinRoom);

document.getElementById("room-key").addEventListener("keypress", (e) => {
    if (e.key === "Enter") joinRoom();
});

// Touch controls
canvas.addEventListener("touchmove", e => {
    e.preventDefault();
    const myPaddle = playerSide === "left" ? leftPaddle : rightPaddle;
    let rect = canvas.getBoundingClientRect();
    let y = e.touches[0].clientY - rect.top;
    myPaddle.y = y - PADDLE_H / 2;
}, { passive: false });

loop();

</script>

</body>
</html>
